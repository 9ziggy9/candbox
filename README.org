#+TITLE: Intro to C for High-Level 'Grammers
#+AUTHOR: 9ziggy9
* Contents :TOC_4:
- [[#disclaimer][DISCLAIMER]]
- [[#preliminaries][Preliminaries]]
    - [[#wtf-do-i-need-to-install][WTF do I need to install?]]
      - [[#linux][Linux]]
      - [[#macos][macOS]]
      - [[#bsd][BSD]]
      - [[#windows][Windows]]
    - [[#makefiles][Makefiles]]
    - [[#building-a-c-project][Building a C project]]
      - [[#examining-the-makefile][Examining the Makefile]]
      - [[#the-path-variable-aka-whats-with--][The /PATH/ variable aka what's with "./" ???]]
      - [[#amending-the-makefile-to-install-software][Amending the Makefile to /install/ software]]
- [[#c-is-what-it-is-and-it-isnt-what-it-isnt][C is what it is and it /isn't what it isn't/]]
    - [[#c-is-weakly-typed][C is *weakly* typed]]
    - [[#hello-world-finally][hello world! (finally)]]
- [[#references][References]]
    - [[#beejs-guide-to-c-programming][Beej's Guide to C Programming]]
    - [[#beejs-other-guides][Beej's other guides]]
    - [[#kr-c][K&R C]]

* DISCLAIMER

#+BEGIN_QUOTE
*DISCLAIMER*:\\

The following is a set of notes on low-level system
programming targetting programmers more accustomed
to the higher-level world of interpreted languages.\\

I am *NOT* an expert in C programming and I can barely
follow any assembler language that is not nasm. This
document may contain many incorrect statements but how
about you and I go toe-to-toe on Bird Law and see who
comes out the victor?\\

#+HTML: <img src="./media/expert.gif" alt="lawyerings" />

Each day we've worked on this repo will be separated into
branches, if you want to follow sequentially as this repo
has evolved, select the branch by day, day-one being the
branch corresponding to the state of the repo at the time
of writing this message.\\

Have fun and please feel free to absolutely roast me for
any and all statements.\\
#+END_QUOTE

* Preliminaries
We are not going to talk C at all until we cover some basic
UNIX OS concepts and discuss build tools. Even if you don't
care about C, this stuff might be useful.
*** WTF do I need to install?
You need a standard compiler and /make/.\\

You have either /gcc/ or /clang/ pre-installed on UNIX-like OSs,
so the only thing you will need is /make/.\\

**** Linux
  If it isn't installed by default then consult your distro's
  package docs. This should return something if it's installed: \\
#+BEGIN_SRC console
which make
#+END_SRC

**** macOS
#+BEGIN_SRC console
brew install make
#+END_SRC

**** BSD
As with Linux, this is going to depend on your BSD flavor
but obviously if you are using BSD you probably shouldn't
be reading this. If you use FreeBSD and you are somehow
unaware, core /make/ in FreeBSD (i.e. what you use for ports)
is not the same thing as the commie GNU /make/
that most people are familiar with. You would need to install
[[https://www.freshports.org/devel/gmake/][gmake]] to be perfectly
consistent with these notes but who cares?
**** Windows
  The best starting place is to [[https://upload.wikimedia.org/wikipedia/commons/2/28/Richard_Stallman_at_LibrePlanet_2019.jpg][install gentoo]]
  first.\\

  Okay fine, then you should probably use [[WSL][WSL]] because
  literally nobody but game devs have the sanity or motivation
  necessary to learn C using Windows APIs.\\

  If you ARE using WSL, you are most likely using Ubuntu:
  #+BEGIN_SRC console
  sudo apt-install make
  #+END_SRC
  There is also [[https://www.cygwin.com/install.html][cygwin]] but I haven't
  the slightest idea how that works, so good luck.\\

*** Makefiles
*IMPORTANT*: You can't copy paste this code because Makefiles
are whitespace sensitive and this org file doesn't preserve
tabs. :( \\

[[https://en.wikipedia.org/wiki/Make_(software)][Makefiles]] are the most
convenient build tool ever created. They have been
around for almost 50 years. You can use them for almost
anything. Start by creating a file titled /Makefile/
and give it a /target/ "hello"
#+BEGIN_SRC makefile
hello:
  echo hello world
#+END_SRC
If you run this via /make/:
#+BEGIN_SRC console
$ make hello
echo hello world
hello world
#+END_SRC
That is, for a specified /target/ the set of *tabbed lines*
directly beneath are the commands which will be ran (called a /recipe/)).
*Makefiles are tab sensitive!*
If you don't want to see the command you invoked, provide
a *@* symbol.
#+BEGIN_SRC makefile
hello:
  @echo hello world
#+END_SRC
#+BEGIN_SRC console
$ make hello
hello world
#+END_SRC
You can provide any number of /targets/.
#+BEGIN_SRC makefile
hello:
  @echo hello world

goodbye:
  @echo goodbye moon
#+END_SRC
#+BEGIN_SRC console
$ make hello
hello world
$ make goodbye
goodbye moon
#+END_SRC
You can also provide any number of /recipes/ to each target.
#+BEGIN_SRC makefile
hello:
  @echo hello world
  @echo hello earth

goodbye:
  @echo goodbye moon
  @echo goodbye sun
#+END_SRC
#+BEGIN_SRC console
$ make hello
hello world
hello earth
$ make goodbye
goodbye moon
goodbye sun
#+END_SRC
/Targets/ can be composed with other /targets/ as /dependencies/.
What this means is that the other /targets/ specified to the 
direct right of the `:` symbol will be evaluated before the
indented /target/ recipes fire.
#+BEGIN_SRC makefile
hello_goodbye: hello goodbye
  @echo all done

hello:
  @echo hello world

goodbye:
  @echo goodbye moon
#+END_SRC
#+BEGIN_SRC console
$ make hello_goodbye
hello world
goodbye moon
all done
#+END_SRC
Incidentally, the top-most /target/ is taken as a default value
if no /target/ is given as an argument to /make/. *NOTE THAT THE*
*TARGET NAMES ARE COMPLETELY ARBITRARY AND THE TOP-MOST WILL*
*ALWAYS SERVE AS THE DEFAULT*:
#+BEGIN_SRC console
$ make
hello world
goodbye moon
all done
#+END_SRC
Like shell scripts, we can bind identifiers to expressions. /make/
will literally inject these values wherever it encounters them within
/$()/. i.e.,
#+BEGIN_SRC makefile
HELLO=hello world
GOODBYE=goodbye moon
CAN_BE_TARGET_TOO_LOL=i literally dont matter

$(CAN_BE_TARGET_TOO_LOL): hello goodbye
  @echo $(CAN_BE_TARGET_TOO_LOL)

hello:
  @echo $(HELLO)

goodbye:
  @echo $(GOODBYE)
#+END_SRC
#+BEGIN_SRC console
$ make
hello world
goodbye moon
i literally dont matter
#+END_SRC
Sometimes in shell scripting we want the output of an evaluated
shell expression, for instance:
#+BEGIN_SRC console
$ echo today is $(date | awk -F: '{ print $1}')
today is Thu Apr 4 01
#+END_SRC
Of course, this couldn't quite work in Makefile as is, how would
the parser distinguish between subtitution and evaluation? Solution:
just add another /$/:
#+BEGIN_SRC makefile
HELLO=hello world
GOODBYE=goodbye moon
CAN_BE_TARGET_TOO_LOL=i literally dont matter

$(CAN_BE_TARGET_TOO_LOL): hello goodbye
  @echo $(CAN_BE_TARGET_TOO_LOL)
  @echo but at least its $$(date | awk -F: '{ print $1 }')

hello:
  @echo $(HELLO)

goodbye:
  @echo $(GOODBYE)
#+END_SRC
#+BEGIN_SRC console
$ make
hello world
goodbye moon
i literally dont matter
but at least its Thu Apr 4 01
#+END_SRC
That's enough for now, we're actually ready to start a C project.
*** Building a C project
Here comes some boilerplate. \\

*filename*: =Makefile=
#+BEGIN_SRC makefile
CC=clang
CFLAGS=-Wall -Wextra -pedantic -Wconversion \
			 -Wunreachable-code -Wswitch-enum -Wno-gnu
EXE=run

all: main.c
	$(CC) main.c -o $(EXE) $(CFLAGS)

clean:
	rm -rf $(EXE)
#+END_SRC

And at last, perhaps the simplest C program imaginable: \\

*filename*: =main.c=
#+BEGIN_SRC c
int main(void) {
  return 0;
}
#+END_SRC

Note that =main.c= should exist at the project's root, together with the
=Makefile=. When after we run /make/, we can run our program by giving
it's executable name _relative_ to our current directory. i.e.,
#+BEGIN_SRC console
$ make && ./run
#+END_SRC

Aaaaaaand.... Nothing happens. :D \\
What this program does it simply return the
number 0 to standard out (/stdout/). It is a convention in UNIX that an "exit
value of zero" is an indication of _success_. \\
It is extremely important that this convention is followed. This is how
we have the capability of running conditional shell commands and applications in
succession. Observe the following behavior with our newly compiled binary:

#+BEGIN_SRC console
$ ./run && echo hello world!
> hello world!
$ ./run || echo "hello world!"
> 
#+END_SRC

Now, you may be asking, "why zero??? wouldn't boolean logic dictate true be
1 as convention?" That is an excellent question! In fact, try running this:

#+BEGIN_SRC console
$ true && echo hello world!
> hello world!
$ true || echo "hello world!"
> 
#+END_SRC

Well dear friends, the `true` command is in fact a /C program which simply
return 0 on every call/*. Lol.
This convention was chosen long, /long/ ago to allow for context to be given
to /any/ *non-zero* exit code.\\

You can view the previous exit code in shell by using the `$?` special variable.
#+BEGIN_SRC console
$ true
$ echo $?
> 0
$ false
$ echo $?
> 1
$ ./run
$ echo $?
> 0
#+END_SRC

*NOTE: most modern shells build this command in, rather than relying on the set
of system core utilities.
[[https://www.gnu.org/software/coreutils/manual/coreutils.html#true-invocation]]

**** Examining the Makefile

*filename*: =Makefile=
#+BEGIN_SRC makefile
CC=clang
CFLAGS=-Wall -Wextra -pedantic -Wconversion \
			 -Wunreachable-code -Wswitch-enum -Wno-gnu
EXE=run

all: main.c
	$(CC) main.c -o $(EXE) $(CFLAGS)

clean:
	rm -rf $(EXE)
#+END_SRC

I have defined a view variables here, /CC/ for instance specifies what compiler
I would like to use, /EXE/ is an identifier for my eventual executable binary.

The /clean/ target is a convenient way that I can remove the previous executable
binary. Probably the most interesting of these variables is /CFLAGS/. Compiler
flags of course are used to set the "strictness" of our compiler (among other
things). I don't want to go into the details of why I have chosen these flags at
the present time, just suffice it to say that this is a very /strict/ set and a
very good collection in my humble opinion.

**** The /PATH/ variable aka what's with "./" ???
In order to execute our application, we MUST specify the path to it's binary.
That is, we cannot simply run it with /run/, that is, not yet.\\

You see, when we run
#+BEGIN_SRC console
$ ./run
#+END_SRC
The operating system transforms the relative path /./run/ into an absolute path
that may look something like: =/home/ziggy/src/my_app/run= \\
In fact, this has to be done for ALL executables.\\
So why is it that some utilities on your machine like /ls/ or /echo/ can be
called without this specification? The answer is through an
/environment variable/ called /PATH/. On my system, my path variable looks like
this:
#+BEGIN_SRC console
$ echo $PATH
> /home/ziggy/.opam/default/bin:/home/ziggy/.opam/default/bin:/home/ziggy/.cabal/bin:/home/ziggy/.ghcup/bin:/home/ziggy/.nvm/versions/nod
e/v21.6.1/bin:/home/ziggy/.cargo/bin:/usr/local/sbin:/usr/local/bin:/usr/bin:/opt/android-sdk/emulator:/opt/android-sdk/tools:/opt/andr
oid-sdk/tools/bin:/usr/lib/jvm/default/bin:/usr/bin/site_perl:/usr/bin/vendor_perl:/usr/bin/core_perl:/home/ziggy/bin:/home/ziggy/third
-party/julia-1.8.4/bin:/home/ziggy/go/bin:/home/ziggy/.local/bin:/home/ziggy/.fzf/bin:/home/ziggy/bin:/home/ziggy/third-party/julia-1.8
.4/bin:/home/ziggy/go/bin:/home/ziggy/.local/bin
#+END_SRC
This enormous variable tells the shell
*what directories contain executables and in what order to search for them.*
Executables contained within these directories can be called without a path
specified because the shell will go through each ":" delimited path and attempt
to append it to the command-name you have called!
To add a /new path/ to the /PATH/ variable, you need only reassign its value!
#+BEGIN_SRC console
$ export PATH=$PATH:/path/to/add
#+END_SRC
One important note is that /user/ specified paths should typically be /appended/
(as opposed to prepended i.e. =PATH=/path/to/add:$PATH=) as we don't want any of
our own personal executables to take precedence. Remember,
*PATH is evaluated from left to right.* If we were to put our executable /run/
at the front of /PATH/, if there were a critical executable on our system also
named /run/, or silly program would be ran /first/.

One final note, in our example we have exported an environment variable but as
many are probably aware, simply exporting an environment variable will not cause
it to /persist/. In order to have our /PATH/ continue to have this amendment
added across shell session (i.e. after closing and opening a new shell), you
will need to add this command to your shell configuration file
(.bashrc, .zshrc, etc).

**** Amending the Makefile to /install/ software
Very often in the wild you will encounter software on the internet which gives
the following instructions for their installation:

#+BEGIN_SRC console
make install clean
#+END_SRC

In fact, there is an entire operating system whose software management
architecture is based on maintaining a set of in /PATH/ directories full
of Makefiles (the port system of FreeBSD).\\

If you would like this functionality, first place a /local/ directory
from which you are comfortable executing binaries from in /PATH/. A very
common choice for this is a local =/bin= directory, =$HOME/bin= for instance.
Once that directory is in /PATH/, simply copying your binary to that directory
would allow you to call it as a normal executable from shell.

*filename*: =Makefile=
#+BEGIN_SRC makefile
CC=clang
CFLAGS=-Wall -Wextra -pedantic -Wconversion \
			 -Wunreachable-code -Wswitch-enum -Wno-gnu
EXE=run
BIN_DIR=$(HOME)/bin

all: build

install: build
  cp $(EXE) $(BIN_DIR)/$(EXE)

build: main.c
	$(CC) main.c -o $(EXE) $(CFLAGS)

clean:
	rm -rf $(EXE)
#+END_SRC

Of course, a person you want to distribute this software to may not have that
directory in PATH, or they may not WANT your executable IN that path. This is
why it is considred *polite* to mark the installation target as /install/.
We can come back to fancy ways to augment our Makefile to assist in installation
but odds are the majority of people who care to even receive this Makefile are
going to understand that they must specify an appropriate /BIN_DIR/.

* C is what it is and it /isn't what it isn't/
*** C is *weakly* typed
In C, only a small set of /primitive/ data types carry any actual /semantics/.
For instance, declaring a /variable/ as /float/ informs the compiler how it
should /process/ the value I am giving it in memory. To us, the /float/ may
carry the /semantics/ of the real number /2.75/, but to the compiler, it knows
to store and /represent/ the underlying /DATA/ as an
IEEE 754 floating-point number and apply arithmetic operations accordingly.
The value /2.75/ to us can, in the real world of computers, be /represented/ as
the value /0x40300000/. That is if you like, the so called IEEE 754 standard
provides an /implementation/ of our "real number" /interface/ we call /float/.\\

Exposing this reality involves a bit of misdirection (later we'll call this
/indirection/ ;)). *WARNING: YOU WILL NOT UNDERSTAND THIS AT THE PRESENT MOMENT*
*THAT IS OKAY*

#+BEGIN_SRC c
#include <stdio.h>

int main(void) {
  float x = 2.75;
  printf("x is %x\n", *(int *) &x);
  return 0;
}
#+END_SRC

#+BEGIN_SRC console
$ make && ./run
> x is 40300000
#+END_SRC

This is an example of something called /type punning/ and it is a mechanism by
which we can circumvent the /type system/ or the (/interface/implementation/
construct of the compiler if you'd like) to get at the underlying /raw/ data
on which the CPU operates.
*IMHO, this capability is what it REALLY means to be WEAKLY typed*. \\

Now, I know what you're thinking,
"wtf is with the /%/, /*/ and /&/ stuff, you haven't even done hello world!"
Well, let's start "hello, world!" and build up in increasing detail until we
understand *this* particular example and by doing so I hope that you will then
understand the scariest of scariest topics in C /what is a pointer?/.
*** hello world! (finally)
Here is hello world in C:
#+BEGIN_SRC c
#include <stdio.h>

int main(void) {
  printf("hello, world!\n");
  return 0;
}
#+END_SRC
The function /printf()/ is provided by the /inclusion/ of the /stdio.h/ /header/
file.
A header /exposes/ the /function prototypes/ (C's notion of an /interface/) of
an often (but not always) pre-compiled library (called an /object/). If all that
if given to you is the /prototype/ of /printf()/, how then can this compile?
Well, /stdio/ is a part of the C /standard library/, and your compiler is nice
enough to /link/ the implementation /objects/ for you. \\
/printf()/ does not automatically add a new line. Hence the additional `\n`.\\
As previously discussed, we return 0 to indicate the program terminated
successfullly.

* References
There is an infinite supply of C programming resources
and I'll note a few here in order of what I feel is the
most helpful.\\
*** [[https://beej.us/guide/bgc/html/][Beej's Guide to C Programming]]
[[https://beej.us/guide/bgnet/html][Beej's Guide to Network Programming]]
is super famous but
this one is just as incredible in my opinion. I wish I had
been aware of thes guides' existence when I first started
writing C. Beej's writing style is incredibly easy to parse
and he has an incredible sense of what students of the C
language tend to struggle with. This guide can be read cover
to cover without any boredom or dullness arising.
*** [[https://beej.us/guide/][Beej's other guides]]
As I mentioned before, Beej's most famous guide is the
Network Programming one but I might as well link his page.
My dude has a way of explaing the things.

*** K&R C
Obviously...
